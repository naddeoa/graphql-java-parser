package org.naddeo.graphql;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.junit.Assert;
import org.junit.Before;
import org.naddeo.graphql.test.data.StreamSizeData;
import org.naddeo.graphql.test.data.TestData;
import org.naddeo.graphql.types.definition.DocumentDefinitionFactory;
import org.naddeo.graphql.types.value.ValueFactory;

import java_cup.runtime.Symbol;

import static java.lang.String.format;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.naddeo.graphql.matchers.GeneratedSymbolClassMatcher.returnsClass;
import static org.naddeo.graphql.matchers.StreamSizeMatcher.containsThisMany;

public abstract class BaseGrammarTest {

    private static final String _parseFailMsg = "'%s' rule did not accept the following valid input:\n%s";
    private static final String _displayFailMsg = "'%s' rule's pojo did not produce a valid, parsable graphql string:\n%s";
    public static final ValueFactory VALUE_FACTORY = new ValueFactory();
    public static final DocumentDefinitionFactory DOCUMENT_DEFINITION_FACTORY = new DocumentDefinitionFactory();

    private boolean previouslyInitialized = false;

    abstract ForcedStatement getTestedRule();

    private GraphQLDocumentParser parser = null;
    private OutputStream output = null;

    @Before
    public void _init() throws IOException
    {
        previouslyInitialized = true;
        PipedInputStream input = new PipedInputStream();
        output = new PipedOutputStream(input);
        parser = new GraphQLDocumentParser(new GraphQLDocumentLexer(new InputStreamReader(input)));
    }

    private Symbol parse(String input) throws Exception
    {
        output.write(input.getBytes());
        output.close();
        return parser.parse();
    }

    private String parseFailMessage(String input)
    {
        return format(_parseFailMsg, getTestedRule().rule, input);
    }

    private String displayFailMessage(String input)
    {
        return format(_displayFailMsg, getTestedRule().rule, input);
    }


    private Symbol assertCan(String query, Function<String,String> messageFunction)
    {
        throwIfNotInitialized();

        Symbol symbol = null;
        try {
            symbol = parse(getTestedRule().create(query));
        } catch (Exception e) {
            e.printStackTrace();
            Assert.fail(messageFunction.apply(query));
        }

        return symbol;
    }

    /**
     * Assert that a graphql query can be parsed
     * @param query a graphql query
     * @return the output of the parser
     */
    Symbol assertCanParse(String query)
    {
        return assertCan(query, this::parseFailMessage);
    }

    /**
     * Same as {@link #assertCanParse(String)}, except the error message is worded
     * around parsing the string that was generated by {@link GraphQLDisplayable#getDisplay()}.
     * @param query a graphql string that was generated by calling {@link GraphQLDisplayable#getDisplay()}
     * @return the output of the parser
     */
    private Symbol assertCanDisplay(String query)
    {
        return assertCan(query, this::displayFailMessage);
    }

    static Collection<TestData[]> parameterize(TestData[] data)
    {
        return Arrays.stream(data).map(d -> new TestData[]{d}).collect(Collectors.toList());
    }

    <T> Symbol assertCanParse(TestData<T> data)
    {
        Symbol symbol = assertCanParse(data.getTest().getParserInput());
        assertThat(assertMessage(), symbol, returnsClass(data.getTest().getExpectedClass()));
        assertThat(assertMessage(), symbol.value, equalTo(data.getTest().getPojoValue()));
        assertStreamSizes(data);

        return symbol;
    }

    /**
     * Assert that a given GraphQL pojo's toDisplay method returns a valid, parsable graphql string.
     * @param data current test case
     */
    <T> void assertCanDisplay(TestData<T> data)
    {
        // TODO remove this if check once everything implements the GraphQLDisplayable interface
        // This will mean that every object is tested in both directions, from parsing to printing.
        if(data.getTest().getPojoValue() instanceof GraphQLDisplayable){
            GraphQLDisplayable displayable = (GraphQLDisplayable)data.getTest().getPojoValue();
            String graphQL = displayable.getDisplay();
            assertCanDisplay(graphQL);
        }
    }

    /**
     * Assert that each of the stream functions returns the expected number of results
     * @param data The data to test
     */
    private <T> void assertStreamSizes(TestData<T> data)
    {
        for(StreamSizeData<T> entry : data.getTest().getStreamSizes()){
            Stream stream = entry.getStreamFunction().apply(data.getTest().getPojoValue());
            assertThat(entry.toString(), stream, containsThisMany(entry.getExpectedResults(), entry.getStreamReturnType()));
        }
    }

    private String assertMessage()
    {
        return String.format("grammar rule '%s': ", getTestedRule().rule);
    }

    private void throwIfNotInitialized()
    {
        if (!previouslyInitialized) {
            throw new IllegalStateException("super.init() was never called. This should go an @Before method.");
        }
    }
}
